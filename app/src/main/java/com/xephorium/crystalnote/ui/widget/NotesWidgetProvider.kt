package com.xephorium.crystalnote.ui.widget

import android.app.Application
import android.app.PendingIntent
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProvider
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.view.View
import android.widget.RemoteViews

import com.xephorium.crystalnote.R
import com.xephorium.crystalnote.data.model.Note
import com.xephorium.crystalnote.data.repository.NoteRoomRepository
import com.xephorium.crystalnote.data.repository.SharedPreferencesRepository
import com.xephorium.crystalnote.ui.select.SelectActivity
import com.xephorium.crystalnote.ui.update.UpdateActivity
import com.xephorium.crystalnote.ui.update.UpdateActivity.Companion.KEY_LAUNCH_FROM_WIDGET
import com.xephorium.crystalnote.ui.update.UpdateActivity.Companion.KEY_NOTE_ID
import java.util.concurrent.Callable
import java.util.concurrent.Executors

/*
  NotesWidgetProvider                               05.11.2019
  Christopher Cruzen

    Defines appearance and view behavior for all note widgets.
*/

class NotesWidgetProvider : AppWidgetProvider() {


    /*--- Lifecycle Methods ---*/

    // Setup Each Widget Instance
    override fun onUpdate(
        context: Context,
        widgetManager: AppWidgetManager,
        widgetIdsPendingUpdate: IntArray
    ) {

        // Create Update Variables
        val sharedPreferencesRepository = SharedPreferencesRepository(context)

        widgetIdsPendingUpdate.let { widgetIds ->

            // For Each Widget
            for (widgetId in widgetIds) {

                // Get Widget Variables
                val widgetView = RemoteViews(context.packageName, R.layout.note_widget_layout)
                val displayNote =
                    sharedPreferencesRepository.getNoteIdForWidget(widgetId)?.let { id ->
                        val callable = Callable<Note> {
                            NoteRoomRepository(context).getNoteSynchronously(id)
                        }
                        val future = Executors.newSingleThreadExecutor().submit(callable)
                        future.get()
                    }

                // Populate Fields
                if (displayNote != null) {

                    widgetView.setViewVisibility(R.id.textWidgetTitle, View.VISIBLE)
                    widgetView.setViewVisibility(R.id.textWidgetContent, View.VISIBLE)
                    widgetView.setViewVisibility(R.id.textWidgetEmpty, View.GONE)

                    widgetView.setTextViewText(R.id.textWidgetTitle, displayNote.name)
                    widgetView.setTextViewText(R.id.textWidgetContent, displayNote.contents)
                } else {
                    widgetView.setViewVisibility(R.id.textWidgetTitle, View.GONE)
                    widgetView.setViewVisibility(R.id.textWidgetContent, View.GONE)
                    widgetView.setViewVisibility(R.id.textWidgetEmpty, View.VISIBLE)
                }

                // Set Listeners
                widgetView.setOnClickPendingIntent(
                        R.id.textWidgetTitle,
                        getOnClickPendingIntent(context, TITLE_CLICK_INTENT, widgetId)
                )
                widgetView.setOnClickPendingIntent(
                        R.id.textWidgetContent,
                        getOnClickPendingIntent(context, TEXT_CLICK_INTENT, widgetId)
                )
                widgetView.setOnClickPendingIntent(
                        R.id.textWidgetEmpty,
                        getOnClickPendingIntent(context, EMPTY_CLICK_INTENT, widgetId)
                )

                widgetManager.updateAppWidget(widgetId, widgetView)
            }
        }
    }

    // Handle Intents Generated by Widget Interaction
    override fun onReceive(context: Context, intent: Intent) {
        super.onReceive(context, intent)

        // Create Receive Variables
        val widgetId = intent.getIntExtra(KEY_WIDGET_ID, 0)

        when (intent.action) {

            TITLE_CLICK_INTENT, TEXT_CLICK_INTENT -> {

                // Update Current Display Note
                SharedPreferencesRepository(context).getNoteIdForWidget(widgetId)?.let { id ->
                    val updateIntent = Intent(context, UpdateActivity::class.java)
                    updateIntent.putExtra(KEY_NOTE_ID, id)
                    updateIntent.putExtra(KEY_LAUNCH_FROM_WIDGET, true)
                    updateIntent.addFlags(
                            Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)
                    context.startActivity(updateIntent)
                }
            }

            EMPTY_CLICK_INTENT -> {

                // Choose New Display Note
                val buttonIntent = Intent(context, SelectActivity::class.java)
                buttonIntent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                buttonIntent.putExtra(KEY_WIDGET_ID, widgetId)
                context.startActivity(buttonIntent)
            }
        }
    }

    override fun onDeleted(context: Context, widgetIds: IntArray) {
        super.onDeleted(context, widgetIds)

        // Remove Widget ID from Shared Preferences
        val sharedPreferencesRepository = SharedPreferencesRepository(context)
        for (widgetId in widgetIds) {
            sharedPreferencesRepository.removeNoteIdForWidget(widgetId)
        }
    }


    /*--- Private Methods ---*/

    private fun getOnClickPendingIntent(
        context: Context,
        intentAction: String,
        widgetId: Int
    ): PendingIntent {
        val intent = Intent(context, this.javaClass)
        intent.action = intentAction
        intent.putExtra(KEY_WIDGET_ID, widgetId)
        return PendingIntent.getBroadcast(
            context,
            widgetId,
            intent,
            PendingIntent.FLAG_CANCEL_CURRENT
        )
    }


    /*--- Constants ---*/

    companion object {
        private const val TITLE_CLICK_INTENT = "com.xephorium.crystalnote.widget.click.TITLE"
        private const val TEXT_CLICK_INTENT = "com.xephorium.crystalnote.widget.click.TEXT"
        private const val EMPTY_CLICK_INTENT = "com.xephorium.crystalnote.widget.click.EMPTY"
        const val KEY_WIDGET_ID = "WIDGET_ID_KEY"

        fun refreshWidgets(context: Context, application: Application) {
            val intent = Intent(context, NotesWidgetProvider::class.java)
            val ids = AppWidgetManager.getInstance(application)
                    .getAppWidgetIds(ComponentName(application, NotesWidgetProvider::class.java))

            intent.action = AppWidgetManager.ACTION_APPWIDGET_UPDATE
            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, ids)
            context.sendBroadcast(intent)
        }
    }
}